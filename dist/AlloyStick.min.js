/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Created by iconie on 20/07/2017.
 */

var Utils = {
    type: {
        isArray: function isArray(o) {
            return o && (o.constructor === Array || ots.call(o) === "[object Array]");
        },
        isObject: function isObject(o) {
            return o && (o.constructor === Object || ots.call(o) === "[object Object]");
        },
        isBoolean: function isBoolean(o) {
            return (o === false || o) && o.constructor === Boolean;
        },
        isNumber: function isNumber(o) {
            return (o === 0 || o) && o.constructor === Number;
        },
        isUndefined: function isUndefined(o) {
            return typeof o === "undefined";
        },
        isNull: function isNull(o) {
            return o === null;
        },
        isFunction: function isFunction(o) {
            return o && o.constructor === Function;
        },
        isString: function isString(o) {
            return (o === "" || o) && o.constructor === String;
        }
    },
    addEvent: function addEvent(eventTarget, eventType, eventHandler) {
        if (eventTarget.addEventListener) {
            eventTarget.addEventListener(eventType, eventHandler, false);
        } else {
            if (eventTarget.attachEvent) {
                eventType = "on" + eventType;
                eventTarget.attachEvent(eventType, eventHandler);
            } else {
                eventTarget["on" + eventType] = eventHandler;
            }
        }
    },
    hasClass: function hasClass(inElement, inClassName) {
        if (!inElement) return;
        var regExp = new RegExp('(?:^|\\s+)' + inClassName + '(?:\\s+|$)');
        return regExp.test(inElement.className);
    },
    addClass: function addClass(inElement, inClassName) {
        if (!inElement) return;
        if (!this.hasClass(inElement, inClassName)) inElement.className = [inElement.className, inClassName].join(' ');
    },
    removeClass: function removeClass(inElement, inClassName) {
        if (!inElement) return;
        if (this.hasClass(inElement, inClassName)) {
            var regExp = new RegExp('(?:^|\\s+)' + inClassName + '(?:\\s+|$)', 'g');
            var curClasses = inElement.className;
            inElement.className = curClasses.replace(regExp, ' ');
        }
    },
    toggleClass: function toggleClass(inElement, inClassName) {
        if (this.hasClass(inElement, inClassName)) this.removeClass(inElement, inClassName);else this.addClass(inElement, inClassName);
    },
    replaceClass: function replaceClass(inElement, oldClass, newClass) {
        if (!inElement) return;
        if (this.hasClass(inElement, oldClass)) {
            var regExp = new RegExp('(?:^|\\s+)' + oldClass + '(?:\\s+|$)', 'g');
            var curClasses = inElement.className;
            inElement.className = curClasses.replace(regExp, ' ' + newClass);
        }
    }
};

exports.default = Utils;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by iconie on 22/07/2017.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 项目入口文件
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _Scene = __webpack_require__(2);

var _Scene2 = _interopRequireDefault(_Scene);

var _Stick = __webpack_require__(4);

var _Stick2 = _interopRequireDefault(_Stick);

var _Utils = __webpack_require__(0);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 通过workFlow的方式,致力于清晰的逻辑并且避免冗余
// todo 暴露更多的API

var AlloyStick = function () {
    function AlloyStick(config) {
        _classCallCheck(this, AlloyStick);

        this.scene = new _Scene2.default(config.context);
        this.roleNumber = 0;
        this.roles = {};
        this.animationStacks = {};
        this.ruleLists = {};
        this.replaceOrWait = '';
    }

    _createClass(AlloyStick, [{
        key: 'addRole',
        value: function addRole(roleConfig, initialAction, initialPosition) {
            var easeConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { ifEase: false };

            if (this.roles.hasOwnProperty(roleConfig.roleName)) {
                console.warn("duplicate names for one scene is not allowed");
                return -1;
            }

            var tempRole = new _Stick2.default(roleConfig);

            tempRole.setEaseType(easeConfig.ifEase, easeConfig.easeFunction);

            // tempRole.playTo(initialAction.animationName, initialAction.totalFrames, initialAction.transitionFrames, initialAction.isLoop);
            tempRole.playTo(initialAction[0], initialAction[1], initialAction[2], initialAction[3]);

            tempRole.setPos(initialPosition.x, initialPosition.y);

            this.scene.addObj(tempRole);
            this.roles[roleConfig.roleName] = tempRole;
            this.roleNumber += 1;
        }
    }, {
        key: 'roleNumbers',
        value: function roleNumbers() {
            return this.roleNumber;
        }
    }, {
        key: 'setVector',
        value: function setVector(roleName) {
            if (!roleName) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.roles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var role = _step.value;

                        role.setVector(true);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            } else {
                this.roles[roleName].setVector(true);
            }
        }
    }, {
        key: 'removeVector',
        value: function removeVector(roleName) {
            if (!roleName) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = this.roles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var role = _step2.value;

                        role.setVector(false);
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            } else {
                this.roles[roleName].setVector(false);
            }
        }

        // 参数可以省略

    }, {
        key: 'showFPS',
        value: function showFPS(dom) {
            this.scene.showFPS(dom);
        }
    }, {
        key: 'hideFPS',
        value: function hideFPS() {
            this.scene.hideFPS();
        }

        /*
        * obj:{value:...,roleName:...}
        * 这个pause实现的功能比较复杂,可以传参数可以不传参数
        */

    }, {
        key: 'pause',
        value: function pause(obj) {
            if (!obj) {
                this.scene.pause();
                return;
            }

            if (obj.hasOwnProperty('roleName')) {
                if (obj.hasOwnProperty('value')) {
                    this.roles[obj['roleName']].pause(obj['value']);
                } else {
                    this.roles[obj['roleName']].pause();
                }
            } else {
                this.scene.pause(obj.value);
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.scene.clear();
        }

        // 给动画增加键盘事件 实际上可以直接读取属性key
        /*
         * 这里其实要考虑比较多的因素：
         * 对于每一个事件,我应该考虑:
         *   如果多个scene对onkeydown和onkeyup进行响应会不会冲突
         *   每一个scene有多个role,我们在指定一个按键的时候是该考虑对某一个role进行某一个动作以及对多个role进行多个动作两种
         *   我们应该指定是在onkeydown的时候响应事件还是在onkeyup的时候响应事件
         *   还要考虑回调函数
         *
         *   只要一个动作进行了,就不会中断,所谓的wait or replace 只是影响下一个动作
         *
         *   lists:
         *   {
         *       's':{ rules:[{role:'xiaoxiao',action:[...]]}
         *       'a':{ rules:[{role:'xiaoxiao',action:[...]]}
         *   }
         *
         *   目前为了方便控制,把callback抽离出来
         *   callBacks{
         *      beforeKeyDown:
         *      afterKeyDown:
         *      beforeKeyUp:
         *      afterKeyUp:
         *   }
         *
         *  为了考虑便于增加，我应该把这个lists存储在整个对象中
         * */

    }, {
        key: 'mapKeyToAni',
        value: function mapKeyToAni(lists, keyDownOrUp, callBacks) {
            var replaceOrWait = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'wait';

            for (var key in lists) {
                if (!lists.hasOwnProperty(key)) continue;
                if (!this.ruleLists.hasOwnProperty(key)) {
                    this.ruleLists[key] = lists[key];
                } else {
                    for (var i = 0; i < lists[key].rules; i += 1) {
                        this.ruleLists[key].push(lists[key].rules[i]);

                        var _that = this;
                        /*
                         if(!this.ruleLists[key].keydown)this.ruleLists[key].keydown = lists[key].keydown;//不管lists[key]指定没指定keydown都可以这样去写,顶多是undefined
                         if(this.ruleLists[key].keydown && lists[key].keydown)this.ruleLists[key].keydown = function(){that.ruleLists[key].keydown();lists[key].keydown()};//如果都指定了,不会replace掉,相当于依次调用
                          if(!this.ruleLists[key].keyup)this.ruleLists[key].keyup = lists[key].keyup;
                         if(this.ruleLists[key].keyup && lists[key].keyup)this.ruleLists[key].keyup = function(){that.ruleLists[key].keyup();lists[key].keyup()};
                         */
                    }
                }
            }

            this.replaceOrWait = replaceOrWait;

            var evt = keyDownOrUp,
                otherEvt = keyDownOrUp === 'keydown' ? "keyup" : "keydown";

            var that = this;

            function handler(e) {

                if (evt === 'keydown') {
                    if (callBacks.beforeKeyDown) callBacks.beforeKeyDown(e);
                } else {
                    if (callBacks.beforeKeyUp) callBacks.beforeKeyUp(e);
                }
                var keys = Object.keys(that.ruleLists);

                if (keys.indexOf(e.key) !== -1) {

                    var certainRule = that.ruleLists[e.key].rules;

                    for (var j = 0; j < certainRule.length; j += 1) {

                        if (that.replaceOrWait === 'wait') {

                            if (that.animationStacks.hasOwnProperty(certainRule[j].role)) {
                                that.animationStacks[certainRule[j].role].push([].concat(_toConsumableArray(certainRule[j].action)));
                            } else {
                                that.animationStacks[certainRule[j].role] = [[].concat(_toConsumableArray(certainRule[j].action))];
                            }
                        } else {
                            that.animationStacks[certainRule[j].role] = [[].concat(_toConsumableArray(certainRule[j].action))];
                        }
                    }
                }

                if (evt === 'keydown') {
                    if (callBacks.afterKeyDown) callBacks.afterKeyDown(e);
                } else {
                    if (callBacks.afterKeyUp) callBacks.afterKeyUp(e);
                }
            }

            function otherHandler(e) {
                if (otherEvt === 'keydown') {
                    if (callBacks.beforeKeyDown) callBacks.beforeKeyDown(e);
                } else {
                    if (callBacks.beforeKeyUp) callBacks.beforeKeyUp(e);
                }
                if (otherEvt === 'keydown') {
                    if (callBacks.afterKeyDown) callBacks.afterKeyDown(e);
                } else {
                    if (callBacks.afterKeyUp) callBacks.afterKeyUp(e);
                }
            }

            _Utils2.default.addEvent(window, evt, handler);
            _Utils2.default.addEvent(window, otherEvt, otherHandler);
        }
    }, {
        key: 'addRules',
        value: function addRules(lists) {
            for (var key in lists) {
                if (!lists.hasOwnProperty(key)) continue;
                if (!this.ruleLists.hasOwnProperty(key)) {
                    this.ruleLists[key] = lists[key];
                } else {
                    for (var i = 0; i < lists[key].rules; i += 1) {
                        this.ruleLists[key].push(lists[key].rules[i]);

                        var that = this;
                    }
                }
            }
        }
    }, {
        key: 'changeReplaceOrWait',
        value: function changeReplaceOrWait(replaceOrWait) {
            this.replaceOrWait = replaceOrWait;
        }
    }, {
        key: 'removeRules',
        value: function removeRules(key, role) {
            if (!this.ruleLists.hasOwnProperty(key)) return;
            if (!role) delete this.ruleLists[key];else {
                for (var j = 0; j < this.ruleLists[key].length; j += 1) {
                    if (this.ruleLists[key][j].role === role) {
                        this.ruleLists[key].splice(j, 1);
                    }
                }
            }
        }
    }, {
        key: 'changeBoneImage',
        value: function changeBoneImage(roleName, boneName, image, positionData) {
            this.roles[roleName].changeBoneImage(boneName, image, positionData);
        }
    }, {
        key: 'rolePlayTo',
        value: function rolePlayTo(roleName, actionConfig) {
            if (!this.roles.hasOwnProperty(roleName)) {
                console.warn("No such role in this scene");
                return -1;
            }

            if (this.replaceOrWait === 'wait') {
                if (this.animationStacks.hasOwnProperty(roleName)) {
                    this.animationStacks[roleName].push([actionConfig]);
                } else {
                    this.animationStacks[roleName] = [[actionConfig]];
                }
            } else {
                this.animationStacks[roleName] = [[actionConfig]];
            }
        }
    }, {
        key: 'start',
        value: function start() {
            var that = this;
            this.scene.start(function () {

                for (var roleName in that.roles) {
                    if (!that.roles.hasOwnProperty(roleName)) continue; // 因为babel没有办法转义新的API,所以这里采用ES5的写法
                    if (that.animationStacks.hasOwnProperty(roleName) && that.animationStacks[roleName].length && that.roles[roleName].isComplete()) {
                        var _that$roles$roleName;

                        var certainAni = that.animationStacks[roleName].shift();
                        (_that$roles$roleName = that.roles[roleName]).playTo.apply(_that$roles$roleName, _toConsumableArray(certainAni));
                    }
                }
            });
        }
    }]);

    return AlloyStick;
}();

exports.default = AlloyStick;


window.AlloyStick = AlloyStick;
window.AlloyUtils = _Utils2.default;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by iconie on 20/07/2017.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AlloyEngine主要提供绘制层功能，AlloyStick主要提供数据层功能
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _Utils = __webpack_require__(0);

var _Utils2 = _interopRequireDefault(_Utils);

var _FpsMonitor = __webpack_require__(3);

var _FpsMonitor2 = _interopRequireDefault(_FpsMonitor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Scene = function () {
    function Scene(context) {
        _classCallCheck(this, Scene);

        this.context = context;
        this.canvas = context.canvas;
        this.children = [];
        this.cb = null; //函数的额外回调函数
        this.paused = false;
        this.fps = 60;
        this.avgFPS = 0; //实际运行的每秒的fps
        this.intervalID = null;
    }

    _createClass(Scene, [{
        key: "addObj",
        value: function addObj(obj) {
            obj.scene = this;
            this.children.push(obj);
        }
    }, {
        key: "removeObj",
        value: function removeObj(obj) {
            var index = this.children.indexOf(obj);
            if (index > 0 || index < this.children.length) {
                this.children.splice(index, 1);
            }
        }
    }, {
        key: "showFPS",
        value: function showFPS(dom) {
            this.fpsInstance = new _FpsMonitor2.default(dom);
        }
    }, {
        key: "hideFPS",
        value: function hideFPS() {
            this.fpsInstance.destory();
            this.fpsInstance = undefined;
        }
    }, {
        key: "start",
        value: function start(cb) {
            // 该函数需要首先被调用
            this.cb = _Utils2.default.type.isFunction(cb) ? cb : null;
            requestAnimationFrame(this.loop.call(this));
        }
    }, {
        key: "pause",
        value: function pause(value) {
            if (value === undefined) {
                this.paused = !this.paused;
            } else {
                this.paused = value;
            }
        }
    }, {
        key: "clear",
        value: function clear(x, y, width, height) {
            if (arguments.length >= 4) {
                this.context.clearRect(x, y, width, height);
            } else {
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }
    }, {
        key: "render",
        value: function render(context, rect) {
            if (!context) context = this.context;
            if (rect) {
                this.clear(rect.x, rect.y, rect.width, rect.height);
            } else {
                this.clear();
            }

            //把Scene中的Obj都render
            for (var i = 0, len = this.children.length; i < len; i++) {
                this.children[i].render(context);
            }
        }
    }, {
        key: "loop",


        /*
        * @iconie 重写loop函数,现在可以针对同一个场景内的不同实例运用不同的fps,从而提供了一种控制相对速度的更好的方法
        * */

        value: function loop() {
            var lastTime = Date.now(),
                frameCountPerSecond = [],
                preCountTimes = [],
                sumDurations = [],
                sumIntervals = [],
                frameDrawCounts = [],
                intervals = [];

            var that = this;
            var reRender = false;

            for (var i = 0; i < this.children.length; i++) {
                frameCountPerSecond[i] = 0;
                preCountTimes[i] = lastTime;
                sumDurations[i] = 0;
                sumIntervals[i] = 0;
                frameDrawCounts[i] = 0;
                intervals[i] = 1000 / this.children[i].fps;
            }

            return function childLoop() {

                var now = Date.now(),
                    duration = now - lastTime;

                for (var _i = 0; _i < that.children.length; _i += 1) {

                    frameCountPerSecond[_i] += 1;

                    if (now - preCountTimes[_i] > 1000) {
                        //每超过一秒更新一些数值记录
                        that.children[_i].avgFPS = frameCountPerSecond[_i];

                        frameCountPerSecond[_i] = 0;
                        preCountTimes[_i] = now;
                        sumDurations[_i] = 0;
                        sumIntervals[_i] = 0;
                        frameDrawCounts[_i] = 1;
                    }

                    if (!that.paused) {
                        sumDurations[_i] += duration;
                        sumIntervals[_i] = intervals[_i] * frameDrawCounts[_i];

                        if (that.children[_i].fps >= 60 || sumDurations[_i] >= sumIntervals[_i]) {
                            that.children[_i].update(duration); //update到下一帧或者下n帧,这个在children中可以进行设置
                            reRender = true;
                            frameDrawCounts[_i] += 1;
                        }
                    }
                }

                if (that.fpsInstance) {
                    that.fpsInstance.monitorFPS(that);
                }

                if (reRender) {
                    if (that.cb) that.cb(duration);
                    that.render(that.context);
                }

                lastTime = now;
                requestAnimationFrame(childLoop);
                reRender = false;
            };
        }
    }]);

    return Scene;
}();

exports.default = Scene;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Created by iconie on 20/07/2017.
 */

var FpsMonitor = function () {
    function FpsMonitor(dom) {
        _classCallCheck(this, FpsMonitor);

        if (dom) {
            this.dom = typeof dom === "string" ? document.querySelector(dom) : dom;
            this.domExistBefore = true;
        } else {
            this.domExistBefore = false;
        }
    }

    _createClass(FpsMonitor, [{
        key: 'monitorFPS',
        value: function monitorFPS(scene) {

            var monitorDom = void 0;
            if (this.dom) {
                monitorDom = this.dom;
            } else {
                monitorDom = document.createElement('div');
                monitorDom.id = 'alloyge_monitor';
                monitorDom.setAttribute('style', 'padding: 10px 15px;background-color:rgba(60,60,60,0.5);position:absolute;top: 0;left: 0;color: #ddd;');
                document.body.appendChild(monitorDom);
                this.dom = monitorDom;
            }

            var str = "";

            for (var i = 0; i < scene.children.length; i += 1) {
                str += scene.children[i].roleName + " fps : " + scene.children[i].avgFPS;
                if (i !== scene.children.length - 1) str += "<BR/>";
            }

            monitorDom.innerHTML = str;
        }
    }, {
        key: 'destory',
        value: function destory() {
            if (!this.domExistBefore) {
                this.dom.parentNode.removeChild(this.dom);
            }
        }
    }]);

    return FpsMonitor;
}();

exports.default = FpsMonitor;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by iconie on 20/07/2017.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _Display = __webpack_require__(5);

var _Display2 = _interopRequireDefault(_Display);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PI = Math.PI;
var HALF_PI = Math.PI * 0.5;
var DEG = PI / 180;

var Node = function () {
    function Node(x, y, rotation) {
        _classCallCheck(this, Node);

        /**  渲染变量 **/
        this.x = x || 0;
        this.y = y || 0;
        this.rotation = rotation || 0;
        this.offR = 0; //是否旋转过一圈 ，所以真实是角度应该是rotation+360*offR
        this.scaleX = 1;
        this.scaleY = 1;
        this.alpha = 1;
        this.frame = 1;
    }

    _createClass(Node, [{
        key: "initValue",
        value: function initValue(data) {
            this.x = data.x;
            this.y = data.y;
            this.rotation = data.rotation;
            this.scaleX = data.scaleX || 1;
            this.scaleY = data.scaleY || 1;
            this.alpha = data.alpha || 1;
            this.frame = data.frame || 1;
            this.offR = data.offR || 0;
        }
    }]);

    return Node;
}();

var TweenNode = function (_Node) {
    _inherits(TweenNode, _Node);

    function TweenNode(x, y, rotation) {
        _classCallCheck(this, TweenNode);

        /**  _sXX起始变量  _dXX差值变量 **/
        //_sXX,_dXX都是用于，根据currentPrencent调用tweento来更新
        var _this = _possibleConstructorReturn(this, (TweenNode.__proto__ || Object.getPrototypeOf(TweenNode)).call(this, x, y, rotation));

        _this._sR = 0; //from节点的rotation
        _this._sX = 0; //from节点的x
        _this._sY = 0; //from节点的y
        _this._sSX = 0; //from节点的scaleX
        _this._sSY = 0; //from节点的scaleY
        _this._sA = 0; //from节点的alpha

        _this._dR = 0; //rotation的差值
        _this._dX = 0; //x的差值
        _this._dY = 0; //y的差值
        _this._dSX = 0; //scaleX的差值
        _this._dSY = 0; //scaleY的差值
        _this._dA = 0; //alpha的差值
        return _this;
    }

    _createClass(TweenNode, [{
        key: "betweenValue",
        value: function betweenValue(from, to) {
            this._sR = from.rotation;
            this._sX = from.x;
            this._sY = from.y;
            this._sSX = from.scaleX;
            this._sSY = from.scaleY;
            this._sA = from.alpha;
            if (to.offR) {
                this._dR = to.rotation + to.offR * 360 - this._sR;
            } else {
                this._dR = to.rotation - this._sR;
            }

            //TODO hack 基于输出数据是跨度不超过180
            if (this._dR > 180) {
                this._dR = this._dR - 360;
            } else if (this._dR < -180) {
                this._dR = this._dR + 360;
            }

            this._dX = to.x - this._sX;
            this._dY = to.y - this._sY;
            this._dSX = to.scaleX - this._sSX;
            this._dSY = to.scaleY - this._sSY;
            this._dA = to.alpha - this._sA;
        }
    }, {
        key: "tweenTo",
        value: function tweenTo(currentPercent) {
            this.rotation = this._sR + this._dR * currentPercent;
            this.x = this._sX + this._dX * currentPercent;
            this.y = this._sY + this._dY * currentPercent;

            if (this._dSX) {
                this.scaleX = this._sSX + this._dSX * currentPercent;
            } else {
                this.scaleX = NaN;
            }
            if (this._dSY) {
                this.scaleY = this._sSY + this._dSY * currentPercent;
            } else {
                this.scaleY = NaN;
            }
            if (this._dA) {
                this.alpha = this._sA + this._dA * currentPercent;
            } else {
                this.alpha = NaN;
            }
        }
    }]);

    return TweenNode;
}(Node);

var Tween = function () {
    function Tween(tweenNode) {
        _classCallCheck(this, Tween);

        this.tweenNode = tweenNode;
        //下面一块的变量是在playTo的时候才具体赋值
        this.nodeList = [];
        this.delay = 0;
        this.transitionFrames = 0; //过渡动画的需要的总帧数
        this.totalFrames = 0; //总帧数 是要演示使用的共多少帧(包括补间帧)
        this.keyFrametotal = 0; //总的关键帧数 区分totalFrames 在playTo的时候才具体赋值
        this.loopTpye = -2; //循环类型，-1静态显示(包括循环不循环)，-2动态循环显示，-3动态不循环显示
        this.ease = true; //默认为true
        this.rate = 1; //显示帧的速率
        this.hasTransition = true; //用于表示过渡动画展示了没有(每次playTo后都重新更新)
        this.currentPercent = 0;
        this.currentFrame = 0;
        this.isComplete = false;
        this.isPause = false;
        this.betweenFrame = 0; //运行到某个关键帧obj的frame
        this.listEndFrame = 0; //某个关键帧obj自身加上前面所有的关键帧obj的frame之和，临界点判断是否要切换from，to的node
    }

    _createClass(Tween, [{
        key: "update",
        value: function update(easeFunction) {
            if (this.isComplete || this.isPause) {
                return;
            }
            if (this.hasTransition) {
                this.currentFrame += this.rate;
                this.currentPercent = this.currentFrame / this.transitionFrames;
                this.currentFrame %= this.transitionFrames;
                if (this.currentPercent < 1) {
                    if (this.ease) {
                        this.currentPercent = Math.sin(this.currentPercent * HALF_PI);
                    }
                } else {
                    /***  这里过渡动画执行结束后，根据loopTpye切换参数更新currentPercen t***/
                    this.hasTransition = false;

                    //静态显示  TODO 输出数据上没有输出静态显示的数据，待优化
                    if (this.loopTpye === -1) {
                        this.currentPrecent = 1;
                        this.isComplete = true; //静态显示设置了isComplete，之后的update都不用做逻辑更新了
                    }
                    //动态循环显示
                    if (this.loopTpye === -2) {
                        if (this.delay !== 0) {
                            this.currentFrame = (1 - this.delay) * this.totalFrames;
                            this.currentPercent += this.currentFrame / this.totalFrames;
                        }
                        this.currentPercent %= 1; //这里我们更新了currentPercent
                        this.listEndFrame = 0;
                    }
                    //动态不循环显示
                    if (this.loopTpye === -3) {
                        this.currentPercent = (this.currentPercent - 1) * this.transitionFrames / this.totalFrames;
                        if (this.currentPercent < 1) {
                            this.currentPrecent %= 1;
                            this.listEndFrame = 0;
                        }
                    }

                    this.updateCurrentPercent(easeFunction);
                }
            } else {
                this.currentFrame += this.rate; //每次update一次都会根据rate(显示速度)增加
                this.currentPercent = this.currentFrame / this.totalFrames;
                this.currentFrame %= this.totalFrames;
                if (this.loopTpye === -3 && this.currentPercent >= 1) {
                    //动态不循环动画在循环动画执行一次后就停止了
                    this.currentPercent = 1;
                    this.isComplete = true;
                } else {
                    this.currentPercent %= 1;
                }

                this.updateCurrentPercent(easeFunction);
            }
            this.tweenNode.tweenTo(this.currentPercent);
        }
    }, {
        key: "updateCurrentPercent",
        value: function updateCurrentPercent(easeFunction) {
            //playedKeyFrames  相对于总关键帧和，运行到某个的当前帧数
            var playedKeyFrames = this.keyFrametotal * this.currentPercent;
            /**
             * 关键帧obj切换的时候更新node差值
             */
            if (playedKeyFrames <= this.listEndFrame - this.betweenFrame || playedKeyFrames > this.listEndFrame) {
                this.listEndFrame = 0;
                var toIndex = 0,
                    fromIndex = 0;
                //循环显示的核心
                while (playedKeyFrames >= this.listEndFrame) {
                    this.betweenFrame = this.nodeList[toIndex].frame;
                    this.listEndFrame += this.betweenFrame;
                    fromIndex = toIndex;
                    //当运动到最后一个关键帧obj的时候，循环动画的时候，我们就使用from为最后一个关键帧obj，to为第一个关键帧obj
                    if (++toIndex >= this.nodeList.length) {
                        toIndex = 0;
                    }
                }

                var fromNode = this.nodeList[fromIndex];
                var toNode = this.nodeList[toIndex];
                //每当切换 关节帧之间的动作 会更新node的差值
                this.tweenNode.betweenValue(fromNode, toNode);
            }

            //这里我们换算currentPrecent，原来的currentPrecent是在总帧数上面，换算当前帧在某个关键帧obj的百分比
            this.currentPercent = 1 - (this.listEndFrame - playedKeyFrames) / this.betweenFrame;
            if (this.ease) {
                if (easeFunction) this.currentPercent = easeFunction(this.currentPercent);else this.currentPercent = 0.5 * (1 - Math.cos(this.currentPercent * PI));
            }
        }
    }]);

    return Tween;
}();

var Bone = function () {
    function Bone(roleName, boneName, display, alloysk) {
        _classCallCheck(this, Bone);

        this.body = null; //继承关系的父亲，一般都是armature类
        this._parent = null; //骨骼上的父子关系
        this.name = boneName;
        this.display = display;
        this.tweenNode = new TweenNode();

        var boneData = alloysk.boneDatas[roleName][boneName] || {};

        this._lockX = boneData.x || 0;
        this._lockY = boneData.y || 0;
        this._lockZ = boneData.z || 0;

        //_parent父骨骼的_transform属性
        this._parentX = 0;
        this._parentY = 0;
        this._parentR = 0;

        //根据update的时候赋值
        this._transformX = 0; //要偏移的x
        this._transformY = 0; //要偏移的y
    }

    _createClass(Bone, [{
        key: "changeImage",
        value: function changeImage(image, positionData) {
            this.display.changeImage(image, positionData);
        }
    }, {
        key: "addChild",
        value: function addChild(child) {
            child._parent = this;
            return child;
        }
    }, {
        key: "getGlobalX",
        value: function getGlobalX() {
            return this._transformX + this._parentX;
        }
    }, {
        key: "getGlobalY",
        value: function getGlobalY() {
            return this._transformY + this._parentY;
        }
    }, {
        key: "getGlobalR",
        value: function getGlobalR() {
            return this.tweenNode.rotation + this._parentR;
        }
    }, {
        key: "update",
        value: function update() {
            //bone的自身update
            if (this._parent) {
                //更新parent属性
                this._parentX = this._parent.getGlobalX();
                this._parentY = this._parent.getGlobalY();
                this._parentR = this._parent.getGlobalR();

                var _dX = this._lockX + this.tweenNode.x;
                var _dY = this._lockY + this.tweenNode.y;
                var _r = Math.atan2(_dY, _dX) /*从 X 轴正向逆时针旋转到点 (x,y) 时经过的角度*/ + this._parentR * DEG;
                var _len = Math.sqrt(_dX * _dX + _dY * _dY);
                this._transformX = _len * Math.cos(_r);
                this._transformY = _len * Math.sin(_r);
            } else {
                //下面这句代码我们可以看出：
                //playTo过后Bone的tweenNode的起值(_sXX)和差值(_dXX)是赋值了，
                //而在这个Bone.update上面现有Tween的update，其实就是Bone.tweenNode的update(本质就是根据currentPercent来tweenTo来使到tweenNode的渲染值得到赋值)
                //所以下面两句代码中的tweenNode.x就是我所说的tween在每次update后的赋值
                this._transformX = this.tweenNode.x;
                this._transformY = this.tweenNode.y;
            }

            //display的update
            this.updateDisplay();
        }
    }, {
        key: "updateDisplay",
        value: function updateDisplay() {
            //也存在没有display渲染层的bone
            if (this.display) {
                this.display.x = this._transformX + this._parentX;
                this.display.y = this._transformY + this._parentY;
                var rotation = this.tweenNode.rotation + this._parentR; //i delete node
                rotation %= 360;
                if (rotation < 0) {
                    rotation += 360;
                }
                this.display.rotation = rotation;

                if (isNaN(this.tweenNode.scaleX)) {} else {
                    this.display.scaleX = this.tweenNode.scaleX;
                }
                if (isNaN(this.tweenNode.scaleY)) {} else {
                    this.display.scaleY = this.tweenNode.scaleY;
                }
                if (!isNaN(this.tweenNode.alpha)) {
                    if (this.tweenNode.alpha) {
                        this.display.visible = true;
                        this.display.alpha = this.tweenNode.alpha;
                    } else {
                        this.display.visible = false;
                    }
                }
            }
        }
    }]);

    return Bone;
}();
/**
 * @obj 包含的内容:
 *   roleName
 *   image
 *   data
 *   fps(optional)
 * */


var Armature = function () {
    function Armature(obj) {
        _classCallCheck(this, Armature);

        this.visible = true;
        this.alpha = 1;
        this.x = 0;
        this.y = 0;

        this.boneList = []; //两种不同的结构对bone的存储
        this.boneObjs = {};
        this.tweenObjs = {}; //装的是骨骼的tween类
        this.roleName = obj.roleName; //记录这个armature的name

        this.fps = obj.fps || 60; //一秒重绘多少次画面，只影响性能(速度？) TODO 目前fps没有应用到具体某个armature,后记统一性能优化处理
        this.avgFPS = 0;
        this.scene = null; //表示这个armature被那个scene add，最重要的是使到两者数据打通
        this.size = 1; //按输出数据的比例播放

        this.boneDatas = obj.data.boneDatas;
        this.textureDatas = obj.data.textureDatas;
        this.animationDatas = obj.data.animationDatas;

        var boneDatas = obj.data.boneDatas[obj.roleName];
        var textureDatas = obj.data.textureDatas[obj.roleName];

        for (var boneName in boneDatas) {
            var boneTd = textureDatas[boneName];
            //TODO Display类优化
            var display = new _Display2.default(obj.image, [boneTd.x, boneTd.y, boneTd.width, boneTd.height, boneTd.originX, boneTd.originY]);
            //这里没有把bone的父子关系逻辑放到构造函数里面，一是由于输出数据的独立性，二是bone可以不依赖关系就可以new出来
            var bone = new Bone(obj.roleName, boneName, display, this);
            bone.body = this; //bone的parent在外面赋值
            this.boneList.push(bone);
            this.boneObjs[boneName] = bone;

            this.tweenObjs[boneName] = new Tween(bone.tweenNode); //这里先赋值上一个空的tween类
        }
        //建立bone的关系
        this.buildJonit();
    }

    _createClass(Armature, [{
        key: "setPos",
        value: function setPos(x, y) {
            this.x = x;
            this.y = y;
        }
    }, {
        key: "setFps",
        value: function setFps(fps) {
            this.fps = fps;
        }
    }, {
        key: "setFrameTotals",
        value: function setFrameTotals(totalFrames) {
            for (var boneName in this.tweenObjs) {
                this.tweenObjs[boneName].totalFrames = totalFrames;
            }
        }
    }, {
        key: "setEaseType",
        value: function setEaseType(type, easeFunction) {
            for (var boneName in this.tweenObjs) {
                this.tweenObjs[boneName].ease = type;
            }
            if (easeFunction) this.easeFunction = easeFunction;
        }
    }, {
        key: "setSize",
        value: function setSize(newSize) {
            for (var boneName in this.boneObjs) {
                this.boneObjs[boneName].display.size = newSize;
            }
        }
    }, {
        key: "isVector",
        value: function isVector() {
            for (var boneName in this.boneObjs) {
                if (this.boneObjs[boneName].display.isVector === false) {
                    return false;
                }
            }
            return true;
        }
    }, {
        key: "setVector",
        value: function setVector(isVector) {
            if (typeof isVector === "undefined") {
                this.setVector(!this.isVector());
            } else {
                for (var boneName in this.boneObjs) {
                    this.boneObjs[boneName].display.isVector = isVector;
                }
            }
        }
    }, {
        key: "isComplete",
        value: function isComplete() {
            //注意不是所有的骨骼的动画总帧数是一样的（如有scale参数的骨骼），所以不能以一代全。
            for (var boneName in this.tweenObjs) {
                if (this.tweenObjs[boneName].isComplete === false) {
                    return false;
                }
            }
            return true;
        }
    }, {
        key: "isPause",
        value: function isPause() {
            for (var boneName in this.tweenObjs) {
                if (this.tweenObjs[boneName].isPause === false) {
                    return false;
                }
            }
            return true;
        }
    }, {
        key: "pause",


        // 目前的逻辑是,也就是原来的逻辑,第一次pause是暂停,再一次pause就是重新开始
        value: function pause(value) {
            if (typeof value === 'undefined') {
                var isPause = this.isPause();
                this.pause(!isPause);
            } else {
                for (var boneName in this.tweenObjs) {
                    this.tweenObjs[boneName].isPause = value;
                }
            }
        }
    }, {
        key: "buildJonit",
        value: function buildJonit() {
            var boneDatas = this.boneDatas[this.roleName],
                boneObjs = this.boneObjs,
                bone = void 0,
                boneData = void 0,
                boneParent = void 0;
            for (var boneName in boneDatas) {
                boneData = boneDatas[boneName];
                bone = boneObjs[boneName];
                boneParent = boneObjs[boneData._parent];
                if (boneParent) {
                    boneParent.addChild(bone); //TODO 实际上这里目前并没有执行到 不知道什么问题
                }
            }
        }
    }, {
        key: "update",
        value: function update(duration) {
            for (var index = 0, len = this.boneList.length; index < len; index++) {
                /************      bone的tweenNode的update   ****************/
                var bone = this.boneList[index];

                //why 不把tween类的更新放到bone类中去？
                //因为有延迟动画的计算，tween类的currentPercent需要重新计算，当把计算currentPercent放到每个骨骼里面去了
                //又会缺少一些全局参数，例如totoalFrame。所以抽离tween类为Armature类统一管理，计算结果自然到bone的tweenNode中
                this.tweenObjs[bone.name].update(this.easeFunction);
                bone.update();
            }
        }
    }, {
        key: "render",
        value: function render(context) {
            if (this.visible && this.alpha > 0) {
                context.save();

                //this.transform(context);
                context.translate(this.x, this.y);

                for (var i = 0; i < this.boneList.length; i++) {
                    this.boneList[i].display._render(context);
                }
                context.restore();
            }
        }
    }, {
        key: "playTo",
        value: function playTo(aniName, totalFrames, transitionFrames, isloop) {
            var aniData = this.animationDatas[this.roleName][aniName],
                fromNode = new TweenNode(),
                toNode = new TweenNode();

            for (var boneName in aniData) {
                if (boneName !== 'name' && boneName !== 'frame') {

                    var bone = this.boneObjs[boneName],
                        boneAniData = aniData[boneName];

                    //tween具体赋值。
                    var tween = this.tweenObjs[boneName];
                    tween.nodeList = boneAniData.nodeList;
                    tween.delay = boneAniData.delay || 0;
                    tween.keyFrametotal = aniData['frame'];
                    tween.totalFrames = totalFrames * (boneAniData.scale || 1);
                    tween.transitionFrames = transitionFrames;
                    tween.hasTransition = true; //重新更新
                    tween.isComplete = tween.isPause = false; //刷新

                    /**************    这里计算的from to 是过渡动画的   ****************/
                    //fromNode使用上一次的tweenNode的渲染值作为起始值，如果上一次没有，则是空值开始
                    fromNode.initValue(tween.tweenNode);

                    if (boneAniData.nodeList.length > 1) {
                        //如果isloop为false，则是动态不循环动画(默认是动态循环动画)
                        if (!isloop) {
                            tween.loopTpye = -3;
                            tween.keyFrametotal -= 1;
                        } else {
                            tween.loopTpye = -2; //这里如果在动画切换的时候上一次是-3，切换回-2的时候，你这里不赋值就出错了。
                        }
                        if (tween.delay !== 0) {
                            // delay比如是0.05
                            // 目前还是有点搞不清楚这个delay有什么用 感觉这个delay不是所谓的延迟,而是延后,这样就能够解释清楚了
                            // 这个delay的计算跟Tween类的updateCurrentPercent方法的逻辑是一模一样的，TODO 看以后可以优化为一个函数不？
                            var playedKeyFrames = tween.keyFrametotal * (1 - tween.delay);
                            var fromIndex = 0,
                                toIndex = 0,
                                listEndFrame = 0,
                                betweenFrame = 0;
                            while (playedKeyFrames >= listEndFrame) {
                                betweenFrame = tween.nodeList[toIndex].frame;
                                listEndFrame += betweenFrame;
                                fromIndex = toIndex;
                                if (++toIndex >= tween.nodeList.length) {
                                    toIndex = 0;
                                }
                            }
                            toNode.betweenValue(tween.nodeList[fromIndex], tween.nodeList[toIndex]);
                            var currentPercent = 1 - (listEndFrame - playedKeyFrames) / betweenFrame;
                            if (tween.ease) {
                                // 如果是缓动就调用缓动函数，
                                if (this.easeFunction) currentPercent = this.easeFunction(currentPercent);else currentPercent = 0.5 * (1 - Math.cos(currentPercent * PI));
                            }
                            toNode.tweenTo(currentPercent);
                        } else {
                            toNode.initValue(aniData[boneName].nodeList[0]);
                        }
                    } else {
                        //静态显示
                        toNode.initValue(aniData[boneName].nodeList[0]); //(数据做了处理，静态显示的也装在只有一个数据的数组里面)
                        tween.loopTpye = -1;
                    }

                    bone.tweenNode.betweenValue(fromNode, toNode);
                }
            }
        }
    }, {
        key: "changeBoneImage",
        value: function changeBoneImage(boneName, image, positionData) {
            this.boneObjs[boneName].changeImage(image, positionData);
        }
    }]);

    return Armature;
}();

exports.default = Armature;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Instance = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by hh on 22/07/2017.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _Utils = __webpack_require__(0);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 包含一些基本的信息,主要是为Display类提供数据支持
var Instance = exports.Instance = function () {
    function Instance() {
        _classCallCheck(this, Instance);

        this.height = 0;
        this.width = 0;
        this.x = 0; // 这个x,y是骨骼的偏移位置（具体实现在bone的updateDisplay的时候具体赋值）
        this.y = 0;
        this.scaleX = 1;
        this.scaleY = 1;
        this.alpha = 1;
        this.originX = 0; // 这里是位图旋转中心，就是决定关节joint的位置
        this.originY = 0; // 如果为0,0就是左上角为旋转中心
        this.rotation = 0;
        this.visible = true;
        this.size = 1; // 骨骼按比例渲染
        this.scene = null;
        this.parent = null;
    }

    _createClass(Instance, [{
        key: "render",
        value: function render() {} // 应该被子类重写

    }, {
        key: "_render",
        value: function _render(context) {
            if (this.visible && this.alpha > 0) {
                context.save();
                this._transform(context); // 根据自身的参数映射到ctx中去
                this.render(context);
                context.restore();
            }
        }
    }, {
        key: "_transform",
        value: function _transform(context) {

            context.translate(this.x * this.size, this.y * this.size);
            if (this.size !== 1) {
                //整体上缩放
                context.scale(this.size, this.size);
            }
            if (this.rotation % 360 > 0) {
                context.rotate(this.rotation % 360 / 180 * Math.PI);
            }
            if (this.scaleX !== 1 || this.scaleY !== 1) {
                context.scale(this.scaleX, this.scaleY);
            }

            context.translate(-this.originX, -this.originY);

            context.globalAlpha *= this.alpha;
        }
    }]);

    return Instance;
}();

/**
 * Display 渲染类
 * 具体有两种渲染方式：矢量渲染和图片渲染
 * x,y是骨骼的偏移位置，具体的由Armature类的x,y决定。
 */


var Display = function (_Instance) {
    _inherits(Display, _Instance);

    function Display(image, frame) {
        _classCallCheck(this, Display);

        var _this = _possibleConstructorReturn(this, (Display.__proto__ || Object.getPrototypeOf(Display)).call(this));

        _this.image = image;
        _this.frame = _Utils2.default.type.isArray(frame) ? frame : [0, 0, image.width, image.height]; //注意位图资源先加载
        _this.width = _this.frame[2];
        _this.height = _this.frame[3];
        _this.originX = -_this.frame[4] || 0; //origin参数在_render方法里面需要
        _this.originY = -_this.frame[5] || 0;
        _this.isVector = false;
        return _this;
    }

    //对实时换装的功能的支持


    _createClass(Display, [{
        key: "changeImage",
        value: function changeImage(image, frame) {
            this.image = image;
            this.frame = _Utils2.default.type.isArray(frame) ? frame : [0, 0, image.width, image.height]; //注意位图资源先加载
            this.width = this.frame[2];
            this.height = this.frame[3];
            this.originX = -this.frame[4] || 0; //origin参数在_render方法里面需要
            this.originY = -this.frame[5] || 0;
        }
    }, {
        key: "render",
        value: function render(context) {
            //  矢量的渲染实现 实际上这个函数虽然每次都被调用，但是并不承担变化功能，相反，我们是每次在_render函数里面改变context(相对运动原理)，所以这就解释了为什么_render中的写法比较奇怪
            if (this.isVector) {
                // 抽象框架方式渲染
                context.strokeStyle = "#aaa";
                context.strokeRect(0, 0, this.width, this.height);
            } else {
                //具体蒙皮方式渲染
                context.drawImage(this.image, this.frame[0], this.frame[1], this.frame[2], this.frame[3], 0, 0, this.width, this.height);
            }
        }
    }]);

    return Display;
}(Instance);

exports.default = Display;

/***/ })
/******/ ]);